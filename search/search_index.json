{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"<p> httpx-aiohttp - provides transports for httpx to work on top of aiohttp, handling all high-level features like authentication, retries, and cookies through httpx, while delegating low-level socket-level HTTP messaging to aiohttp </p>"},{"location":"#via-httpxaiohttpclient","title":"via HttpxAiohttpClient","text":"<p>The <code>HttpxAiohttpClient</code> class is an alternative to the <code>AsyncClient</code> class that changes the underlying transport from the default <code>AsyncHTTPTransport</code> to <code>AiohttpTransport</code>.</p> <pre><code>import asyncio\nfrom httpx_aiohttp import HttpxAiohttpClient\n\n\nasync def main() -&gt; None:\n    async with HttpxAiohttpClient() as client:\n        response = await client.get(\"https://encode.io\")\n        print(response)\n\nasyncio.run(main())\n</code></pre>"},{"location":"#via-aiohttptransport","title":"via AiohttpTransport","text":"<p>You can also change the transport itself by passing the transport object to the default <code>AsyncClient</code>, asking it to use that particular transport.</p> <pre><code>import httpx\nimport asyncio\nfrom httpx_aiohttp import AiohttpTransport\n\n\nasync def main() -&gt; None:\n    async with httpx.AsyncClient(transport=AiohttpTransport()) as client:\n        response = await client.get(\"https://encode.io.com\")\n        print(response)\n\n\nasyncio.run(main())\n</code></pre> <p>Choose your option carefully</p> <p>If you aren't familiar with how the client operates with transports, it's preferable to replace the client with the one that httpx_aiohttp provides. Providing a transport forces the client to use that transport by default or for some particular URL pattern, so some client arguments won't work (for example, client timeout configurations won't be respected when you provide your own transport).</p>"},{"location":"compatibility/","title":"Compatibility","text":"<p>You may encounter some differences when working with alternative transports. This page describes the differences between the default transport and the aiohttp-powered one.</p>"},{"location":"compatibility/#timeouts","title":"Timeouts","text":"<p>Timeouts will work for the aiohttp-powered transport, except for the write timeout, which isn't currently supported in aiohttp.</p> <pre><code>import asyncio\nfrom httpx_aiohttp import HttpxAiohttpClient\n\n\nasync def main() -&gt; None:\n    async with HttpxAiohttpClient() as client:\n        response = await httpx_client.get(\"https://www.encode.io\", timeout=httpx.Timeout(\n            connect=5.0,\n            read=5.0,\n            pool=5.0,\n            write=None  # Aiohttp doesn't support write timeout\n        ))\n        print(response)\n\nasyncio.run(main())\n</code></pre>"},{"location":"compatibility/#proxies","title":"Proxies","text":"<p>HTTP proxies will work as expected, though aiohttp doesn't have built-in support for SOCKS and HTTPS proxies like httpx does. If you want to use SOCKS proxies, for example, you can inject a third-party SOCKS implementation client session (such as aiohttp-socks) into the httpx client.</p> <pre><code>import asyncio\nfrom httpx_aiohttp import HttpxAiohttpClient\n\nasync def main() -&gt; None:\n    async with HttpxAiohttpClient(\n        proxy=\"http://127.0.0.1:9001\",  # you can use mitmproxy\n    ) as client:\n        response = await client.get(\"http://www.encode.io\")\n        print(response)\n\n\nasyncio.run(main())\n</code></pre>"},{"location":"compatibility/#event-hooks","title":"Event hooks","text":"<p>Event hooks will not work for the aiohttp-powered transport because hooks are called from httpcore, and aiohttp doesn't support them.</p>"},{"location":"compatibility/#extensions","title":"Extensions","text":"<p>Extensions trace, target, stream_id and network_stream are also not supported.</p>"},{"location":"how_it_works/","title":"How it works","text":""},{"location":"how_it_works/#httpxs-split-design","title":"HTTPX's split design","text":"<p>It's very important to understand that httpx itself is not making any requests, not opening any connections, or doing such things\u2014it just delegates that work to another library.</p> <p>You can think of httpx as a sans-io library\u2014it doesn't perform any IO operations, but instead has a great design that allows you to bring your own IO. It comes with a default library for IO called httpcore, but you can use another one if you encounter issues with it.</p> <p>There is a wonderful talk by the author of those libraries (Tom Christie); you can also take a look for more context.</p> <p>In a nutshell, httpx connects to the underlying HTTP implementation through the transport interface, which has a single method (+ some startup/teardown methods with the default implementation) called <code>handle_request</code> that looks like this:</p> <pre><code>class BaseTransport:\n    def __enter__(self: T) -&gt; T:\n        return self\n\n    def __exit__(\n        self,\n        exc_type: type[BaseException] | None = None,\n        exc_value: BaseException | None = None,\n        traceback: TracebackType | None = None,\n    ) -&gt; None:\n        self.close()\n\n    def handle_request(self, request: Request) -&gt; Response:\n        raise NotImplementedError()\n\n    def close(self) -&gt; None:\n        ...\n</code></pre> <p>And for async one:</p> <pre><code>class AsyncBaseTransport:\n    async def __aenter__(self: A) -&gt; A:\n        return self\n\n    async def __aexit__(\n        self,\n        exc_type: type[BaseException] | None = None,\n        exc_value: BaseException | None = None,\n        traceback: TracebackType | None = None,\n    ) -&gt; None:\n        await self.aclose()\n\n    async def handle_async_request(\n        self,\n        request: Request,\n    ) -&gt; Response:\n        raise NotImplementedError()\n\n    async def aclose(self) -&gt; None:\n        pass\n</code></pre> <p>This means you can write your own transports that connect to other low-level implementations such as aiohttp, urllib3, or curl. You may have noticed that you can make requests to ASGI and WSGI apps directly with httpx\u2014this is because someone wrote transports that connect to these apps.</p> <p>This library implements the AsyncBaseTransport interface to connect httpx to aiohttp, so all the high-level operations are handled by httpx while delegating network layer tasks to aiohttp.</p> <p>Warning</p> <p>When you write your own transport, you should ensure that the underlying implementation doesn't handle ANYTHING except the actual request sending and proxy connection handling, so all the high-level tasks will be handled by httpx and only by it! You won't have duplicate compression, authentication, or redirect handling\u2014you should disable all of these features in the underlying implementation.</p>"},{"location":"how_its_tested/","title":"How it's tested?","text":"<p>httpx-aiohttp uses httpx as a submodule and runs all the original httpx tests while mocking the underlying transport, so our new custom transport will be used during tests.</p> <p>There is a simple script in the <code>./scripts/run_tests.py</code> file that mocks the default transport and invokes pytest programmatically. Currently, we are passing all 1200+ tests.</p>"},{"location":"why/","title":"Why?","text":"<p>The original reason was the performance issues that developers faced. Although httpcore, which comes by default, has more features, aiohttp seems to be more stable and has better performance.</p>"}]}